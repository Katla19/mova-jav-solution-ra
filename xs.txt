
Domino Piles
Problem
Submissions
You are given a rectangular board of M × N squares. Also you are given an unlimited number of standard domino pieces of 2 × 1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1.Each domino completely covers two squares.

2.No two dominoes overlap.

3.Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.

Input Format

In a single line you are given two integers M and N — board sizes in squares

Constraints

1 ≤ M ≤ N ≤ 16

Output Format

Output one number — the maximal number of dominoes, which can be placed.

Sample Input 0

2 4
Sample Output 0

4


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
     
    int a,b,c;
        Scanner sc=new Scanner(System.in);
        a=sc.nextInt();
        b=sc.nextInt();
        if(b==1){
           System.out.println(a/2);
       
        }
        else{
            if(b%2==0){
                System.out.println(a*(b/2));
               
            }
            else{
                System.out.println((a*((b-1)/2))+a/2);
                }
        }
    }
}




Z 412 The Slopes of Line Segments
Problem
Submissions
In the town of line segments two line segments can only become friends if their slopes are equal. Line segments are not smart enough to calculate their own or some other line segment's slope so they use a machine called the slopeFinder to check their compatibility. Recently someone stole the slopeFinder and now the line segments are upset because they cannot make new friends. The Mayor of the town has hired you to write a code to fix the crisis that their town is facing.

Input Format

Input Contains two line segments each on a line of its own. Each line segment is denoted by four integers Xa, Ya, Xb and Yb where (Xa,Ya) and (Xb, Yb) denote the two end points of the line segment.

Constraints

0 <= |Xa|,|Xb|,|Ya|,|Yb| <= 100

Output Format

Output "yes" if both the line segments have the same slope and "no" otherwise. (without the quotes).

Sample Input 0

0 0 1 1
1 0 2 1
Sample Output 0

yes
Sample Input 1

0 0 1 1
2 1 3 0
Sample Output 1

no




import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int slope1=0,slope2=0;
        int xa1=in.nextInt();
        int ya1=in.nextInt();
        int xb1=in.nextInt();
        int yb1=in.nextInt();
        int xa2=in.nextInt();
        int ya2=in.nextInt();
        int xb2=in.nextInt();
        int yb2=in.nextInt();
        if(xa1!=xb1 && xa2!=xb2){
            slope1=(yb1-ya1)/(xb1-xa1);
            slope2=(yb2-ya2)/(xb2-xa2);
            if(slope1==slope2){
                System.out.println("yes");
            }
            else{
                System.out.println("no");
            }
   
           
           
        }
        else{
            if(xa1==xb1)slope1=1000;
            if(xa2==xb2)slope2=1000;
            if(slope1==slope2) System.out.println("yes");
            else System.out.println("no");
        }
    }
}





D M01 - Great Pattern
Problem
Submissions
Your task is simple, write a program in Java to print the following pattern :

N = 1
1

N = 2
  1
1 2 1
  1
  
N = 3
    1
  1 2 1
1 2 3 2 1
  1 2 1
    1
    
and so on..
INPUT
Input consists of many test cases.
First line contains the number of test case T.
Each of the test case lines consists of one number N for that test case.

OUTPUT
Print the pattern corresponding to the N value of each test case.
Print a blank line between two test case outputs.

CONSTRAINTS
1 ≤ T, N ≤ 10

Sample Input 0

3
1
2
3
Sample Output 0

1

  1
1 2 1
  1
  
    1
  1 2 1
1 2 3 2 1
  1 2 1
    1


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        while(t>0){
            int n=sc.nextInt();
            for(int i=1;i<=n;i++){
                for(int j=0;j<n-i;j++){
                    System.out.print("  ");
                }
                for(int j=1;j<=i;j++){
                  System.out.print(j+" ");
                }
               for(int j=i-1;j>=1;j--){
                     System.out.print(j+" ");
               }
                System.out.println();
            }
            for(int i=n-1;i>=1;i--){
                for(int j=1;j<=n-i;j++){
                     System.out.print("  ");
                }
               for(int j=1;j<=i;j++){
                   System.out.print(j+" ");
                }
                for(int j=i-1;j>=1;j--){
                    System.out.print(j+" ");
                }
                System.out.println();
             }
            System.out.println();
            t--;
        }
    }
}


Super Prime Number
Problem
Submissions
Hi! Itsa Me! aMario! While plumping my way through the town looking for my princess, I talked to a duck that told me about prime numbers. Apparently a prime number is a number that only has two divisors, i.e. 1 and itself. Interesting isnt it? Being the Super Mario that I am, I decided to come up with the concept of a super prime number. Formally, a super prime number is a number sum of all of whose divisors except itself is prime i.e. sum of every divisor of a number except itself being prime makes the number a super prime number. I have Q queries regarding super prime numbers. Each query is a number and I need to know if the number is super prime or not. Can you help me?

Input Format

First line contains the number of queries Q.
Next Q lines contain one integer each denoting the numbers associated with the queries.

Constraints

1 <= Q <= 10^5
1 <= queries <= 10^5

Output Format

For every query print YES if the number is a super prime number and print NO otherwise. Output must contain Q lines, each line containing the answer to one query.

Sample Input 0

4
4 5 9 8
Sample Output 0

YES
NO
NO
YES



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    static int SoD(int n){
           int sum=0;
            for (int i=1;i<=Math.sqrt(n);i++){
                if (n%i==0){
                    if (n/i == i)
                    sum=sum+i;
      
                else // Otherwise print both
                    sum=sum+i+(n/i);
                }
            }
           return (sum-n);
        }
    static boolean isPrime(int n)
    {
 
        // Check if number is less than
        // equal to 1
        if (n <= 1)
            return false;
 
        // Check if number is 2
        else if (n == 2)
            return true;
 
        // Check if n is a multiple of 2
        else if (n % 2 == 0)
            return false;
 
        // If not, then just check the odds
        for (int i = 3; i <= Math.sqrt(n); i += 2)
        {
            if (n % i == 0)
                return false;
        }
        return true;
    }
 

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int t=0;
        for(int i=0 ;i<n;i++){
            t=sc.nextInt();
            if(isPrime(SoD(t))){
                System.out.println("YES");
            }
            else{
                System.out.println("NO");
            }
        }
    }
}





T 131 - Confused Integer
Problem
Submissions
Our beloved integer X is confused. He was told that he is a positive integer which fits in a 32 bit signed integer that can be expressed as A^P where P > 1 and A > 0 where A and P both should be integers. Now he wonders, there is a possibility that he does not exist at all because he does not satisfy the A^P expressibility condition. Given the values of A and P, find out if X exists or not.

Input Format

Input contains the value of integer X.

Constraints

0 < X < 2x10^9

Output Format

Output "yes" if X can be expressed as A^P and "no" otherwise.

Sample Input 0

4
Sample Output 0

yes
Explanation 0

Yes as 2^2 = 4



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int flag=0;
        for(int i=0;i<=Math.sqrt(n);i++){
            for(int j=0;j<=Math.sqrt(n);j++){
                if((long)(Math.pow(i,j))==n){
                    flag=1;
                }
            }
        }
        if(flag==1){
            System.out.println("yes");
        }
        else{
            System.out.println("no");
        }
    }
}




G M04 - The Elite N
Problem
Submissions
The Elite N are a number of people in a line, that you have to beat in order to be the Pokémon Champion.
Each person has exactly one Pokémon, with a predetermined power level.
When a battle occurs, the powers of both Pokémon steadily decrease until either reaches 0. This will be referred to as fainting.
You have to make sure your Pokémon doesn't faint, i.e., its power should remain > 0
You can take rest and restore your Pokémon to full power to start battling again. But it takes one day to do so.
When you rest the current opponent also takes a rest restoring his powers to full.
You can fight as many battles as possible in a day until you rest.
Find the number of days you will need to defeat the Elite N and become the champion.
Note that there might be a person stronger than you whom you cannot defeat. Hence you will have to lose.
Print the number of days required to defeat the Elite N, and -1 if you can't.
Input Format

The first line of input contains your Pokémon's power, K. The second line contains the number of opponents, N. The next line contains n numbers A1, A2 ... An, where Ai is the power of the ith opponent.

Constraints

1 <= k <= 1000

1 <= n <= 100000

1 <= a1, a2, a3, ..., an <= 1000

Output Format

Output only one number, the number of days taken to defeat the Elite N.

Sample Input

10

7

1 2 4 7 2 5 5

Sample Output

4

Explanation

On the first day you defeat 1st, 2nd and 3rd opponent. As the remaining power would be 3, you can't battle the 4th one. So you take rest. On the 2nd day, you defeat the 4th and the 5th opponent, then take rest. On the 3rd day, you defeat the 6th enemy only. As you cannot let your pokemon faint, you will have to take rest. On the 4th day you defeat the last of the Elite N and become the champion! :D




import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int k=sc.nextInt();
        int n=sc.nextInt();
        int po,current=k,l=1,m=0;
        for(int i=0;i<n;i++){
            po=sc.nextInt();
            if(k<=po){
                m=1;
            }
            if(po>=current){
                l++;
                current=k;
            }
            current=current-po;
        }
        if(current==0){
            l++;
        }
        if(m==0){
            System.out.println(l);
        }
        else{
            System.out.println("-1");
        }
    }
}



B D01 - Find The Coders DayB D01
Day of the Programmer
Marie invented a Time Machine and wants to test it by time-traveling to visit Russia on the Day of the Programmer (the 256th day of the year) during a year in the inclusive range from 1700 to 2700.

From 1700 to 1917, Russia's official calendar was the Julian calendar; since 1919 they used the Gregorian calendar system. The transition from the Julian to Gregorian calendar system occurred in 1918, when the next day after January 31st was February 14th. This means that in 1918, February 14th was the 32nd day of the year in Russia.

In both calendar systems, February is the only month with a variable amount of days; it has 29 days during a leap year, and 28 days during all other years. In the Julian calendar, leap years are divisible by 4; in the Gregorian calendar, leap years are either of the following:

Divisible by 400.
Divisible by 4 and not divisible by 100.
Given a year, , find the date of the 256th day of that year according to the official Russian calendar during that year. Then print it in the format dd.mm.yyyy, where dd is the two-digit day, mm is the two-digit month, and yyyy is .

For example, the given  = 1984. 1984 is divisible by 4, so it is a leap year. The 256th day of a leap year after 1918 is September 12, so the answer is .

Function Description

Complete the dayOfProgrammer function in the editor below. It should return a string representing the date of the 256th day of the year given.

dayOfProgrammer has the following parameter(s):

year: an integer
Input Format

A single integer denoting year .

Constraints

1700 \le y \le 2700
Output Format

Print the full date of Day of the Programmer during year  in the format dd.mm.yyyy, where dd is the two-digit day, mm is the two-digit month, and yyyy is .

Sample Input 0

2017
Sample Output 0

13.09.2017
Explanation 0

In the year  = 2017, January has 31 days, February has 28 days, March has 31 days, April has 30 days, May has 31 days, June has 30 days, July has 31 days, and August has 31 days. When we sum the total number of days in the first eight months, we get 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 = 243. Day of the Programmer is the 256th day, so then calculate 256 - 243 = 13 to determine that it falls on day 13 of the 9th month (September). We then print the full date in the specified format, which is 13.09.2017.

Sample Input 1

2016
Sample Output 1

12.09.2016
Explanation 1

Year  = 2016 is a leap year, so February has 29 days but all the other months have the same number of days as in 2017. When we sum the total number of days in the first eight months, we get 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 = 244. Day of the Programmer is the 256th day, so then calculate 256 - 244 = 12 to determine that it falls on day 12 of the 9th month (September). We then print the full date in the specified format, which is 12.09.2016.

Sample Input 2

1800
Sample Output 2

12.09.1800
Explanation 2

Since 1800 is leap year as per Julian calendar. Day lies on 12 September.

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int year=sc.nextInt();
        if(year<=1918){
            if(year==1918){
                System.out.println("26.09.1918");
            }
            else{
                if(year%4==0){
                    System.out.println("12.09."+year);
                }
                else{
                    System.out.println("13.09."+year);
                }
            }
        }
        else{
            if((year%400==0)||((year%4==0)&&(year%100!=0))){
                    System.out.println("12.09."+year);
                }
                else{
                    System.out.println("13.09."+year);
                }
        }
        
    }
}




C D09 - To and Fro
Problem
Submissions
A futuristic company is building an autonomous car. The scientists at the company are training the car to perform Reverse parking. To park, the car needs to be able to move in backward as well as forward direction. The car is programmed to move backwards B meters and forwards again, say F meters, in a straight line. The car does this repeatedly until it is able to park or collides with other objects. The car covers 1 meter in T units of time. There is a wall after distance D from car's initial position in the backward direction.

The car is currently not without defects and hence often hits the wall. The scientists are devising a strategy to prevent this from happening. Your task is to help the scientists by providing them with exact information on amount of time available before the car hits the wall.

Input Format:

First line contains total number of test cases, denoted by N Next N lines, contain a tuple containing 4 values delimited by space F B T D, where 1. F denotes forward displacement in meters 2. B denotes backward displacement in meters 3. T denotes time taken to cover 1 meter 4. D denotes distance from Car's starting position and the wall in backward direction

Output Format:

For each test case print time taken by the Car to hit the wall

Constraints:
First move will always be in backward direction
1 <= N <= 100
backward displacement > forward displacement i.e. (B > F)
forward displacement (F) > 0
backward displacement (B) > 0
time (T) > 0
distance (D) > 0
All input values must be positive integers only

Sample Input 0

2
6 9 3 18
3 7 5 20
Sample Output 0

162
220




import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        while(n!=0){
            int f=sc.nextInt();
            int d=sc.nextInt();
            int c=sc.nextInt();
            int dist=sc.nextInt();
            int b=0;
            while(dist>d){
                b=b+d+f;
                dist=dist-d+f;
            }
            b=b+dist;
            System.out.println(b*c);
            n--;
        }
    }
}




Identify and print the following pattern generated by prime numbers for a given N.

N = 1
2

N = 2
2
3 5

N = 3
2
3 5
7 11 13
Input
Input consists of a single integer N

Output
Output must consists of the pattern as shown above.

Sample Input 0

3
Sample Output 0

2
3 5
7 11 13



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int m=sc.nextInt();
        int ct=0,n=0,i=1,j=1;
        int[] a=new int[m*(m+1)/2];
        while(n<m*(m+1)/2){  
            j=1;  
            ct=0;  
            while(j<=i){  
                if(i%j==0)  
                    ct++;  
                j++;   
            }  
            if(ct==2){  
                a[n]=i;  
                n++;  
            }      
            i++;  
        }  
        n=0;
        for(i=0;i<m;i++){
            for(j=0;j<i+1;j++){
                System.out.print(a[n]+" ");
                n++;
            }
            System.out.println();
        }
    }
}






Given an array of integers, replace every element with the greatest element on the right side in the array. Replace last element with 0 as there no element on the right side of it.

Input Format

First line contains N , the number of Numbers. Next line contains N integers a[1]..a[n] the numbers

Constraints

1<= N <= 10^5
1<= ai <= 10^5

Output Format

Print the array required

Sample Input 0


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[] a=new int[n];
        int[] b=new int[n];
        for(int i=0;i<n;i++){
            a[i] = sc.nextInt();   
        }
        int max=a[n-1];
        b[n-1]=0;
        b[n-2]=max;
        for(int i=2;i<n;i++){
            if(a[n-i]>max){
                max=a[n-i];
                b[n-i-1]=max;
            }
            else{
                b[n-i-1]=max;
            }
        }
        for(int i=0;i<n;i++){
            System.out.print(b[i]+" ");
        }
    }
}




As simple as the title, given a number N, print the number of digits in N!

N! is defined as : N! = 1*2*3...(N-1)*N

0! = 0 and 1! = 1.

No number ever contains any leading zeros.

Input Format

Input contains only one number, N.

Constraints

1 <= N <= 1000

Output Format

Output one number that is equal to the number of digits in N!

Sample Input 0

6
Sample Output 0

3
Explanation 0

6! = 1x2x3x4x5x6 = 720 which has 3 digits. So the answer is 3.




import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        double k=0;
        for(int i=2;i<n+1;i++){
            k+=Math.log10(i);
        }
        System.out.println((int)k+1);
    }
}



Using inheritance, one class can acquire the properties of others. Consider the following HumanBeing class.

class HumanBeing{
    void eat(){
        System.out.println("I am eating");
    }
}
The class has only one method, eat. Next, we want to create another Teenager class that also has the beArrogant method. We can do this using the extends keyword :

class Teenager extends HumanBeing {
    void beArrogant() {
        System.out.println("I am being arrogant");
    }
}
Finally, we can create a Teenager object that can both eat and be arrogant at the same time.

public class Solution{
   public static void main(String[] args){

      Teenager teen = new Teenager();
      teen.eat();
      teen.beArrogant();
   }
}
The above code will print :

I am eating
I am being arrogant
This means that a Teenager object has all the properties that a HumanBeing object has, as well as some additional unique properties.

The code above is provided for you in your editor. You must add a reasonlessRebel method to the Teenager class, so that the code prints the following lines:

I am eating
I am being arrogant
I am a rebel
NOTE :
Do not make any changes to the head or the tail of the code


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

class HumanBeing{
	void eat(){
		System.out.println("I am eating");
	}
}

//BODY OF THE CODE BEGINS HERE
class Teenager extends HumanBeing{
	void beArrogant(){
		System.out.println("I am being arrogant");
	}
}
//BODY OF THE CODE ENDS HERE


public class Solution{

   public static void main(String args[]){
	  Teenager teen = new Teenager();
	  teen.eat();
	  teen.beArrogant();
      teen.reasonlessRebel();
   }
}







OO 02 - Basics of Inheritance - II
Problem
Submissions
Write the code for the following in the editor below :

A class named Arithmetic with a method named multiply that takes as parameters two integers and returns their product.
A class named Multiplier that inherits from the superclass named Arithmetic.
Your classes should be public.

Input Format

You are not responsible for reading any input from stdin; a code stub will test your submission by calling the multiply method on a Multiplier object and passing it 2 integer parameters.

You only need to write the code for the Arithmetic class and the Multiplier class

Output Format

You are not responsible for printing anything to stdout. Your multiply method must return the product of its parameters.

Sample Output :
The main method in the Solution class above should print the following:

My superclass is: Arithmetic
50 100 200





import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

//BODY BEGINS HERE
class Arithmetic{
    public int multiply(int a,int b){
        return(a*b);
    }
}
class Multiplier extends Arithmetic{
    public int demultiply(int a,int b){
        return(multiply(a,b));
    
    }
}



//BODY ENDS HERE

public class Solution{
    public static void main(String []args){
        // Create a new Multiplier object
        Multiplier a = new Multiplier();
        
        // Print the name of the superclass on a new line
        System.out.println("My superclass is: " + a.getClass().getSuperclass().getName());	
        
        // Print the result of 3 calls to Multiplier's `multiply(int,int)` method as 3 space-separated integers:
        System.out.print(a.multiply(5,10) + " " + a.multiply(10,10) + " " + a.multiply(20,10) + "\n");
     }
}





In Java an abstract class is a class that may or may not have abstract functions.

Abstract classes cannot be initiated directly because they may contain functions that lack implementation.

Similarly, abstract functions are those functions that do not have an implementation.

To initiate abstract classes, one must inherit them to another class and write the implementations for the abstract functions in order to use them.

In the current problem you are given an abstract class as follows :

abstract class Arithmetic
{
    abstract int add(int, int);
    abstract int subtract(int, int);
    abstract int divide(int, int);
    abstract int multiply(int, int);
}
Your task is to write a new class called Calculator that inherits the class Arithmetic and implement all its functions.

NOTE:
You are only allowed to edit the body of the code.

Input Format

You are not responsible for any form of input or output.
Your only task is to implement the Calculator class.



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

abstract class Arithmetic
{
  abstract int add(int x, int y);
  abstract int subtract(int x, int y);
  abstract int multiply(int x, int y);
  abstract int divide(int x , int y);
}

//BODY STARTS HERE

class Calculator extends Arithmetic{
  
        int add(int a,int b){
            return (a+b);
        }
        int subtract(int a,int b){
            return (a-b);
        }
        int multiply(int a,int b){
            return (a*b);
        }
        int divide(int a,int b){
            return (a/b);
        }
}
//BODY ENDS HERE


public class Solution{
  public static void main(String args[])
  {
    Calculator cal = new Calculator();
   	int A = 10, B = 5;
   	System.out.println("Addition Result : " + cal.add(A, B));
    System.out.println("Subtraction Result : " + cal.subtract(A, B));
    System.out.println("Multiplication Result : " + cal.multiply(A, B));
    System.out.println("Division Result : " + cal.divide(A, B));
  }
}



A Java interface can only contain method signatures and fields. The interface can be used to achieve polymorphism. In this problem, you will practice your knowledge on interfaces.

You are given an interface AdvancedArithmetic which contains a method signature int divisor_count(int n). You need to write a class called MyCalculator which implements the interface.

divisor_count function just takes an integer as input and return the total number of its divisors. For example divisors of 6 are 1, 2, 3 and 6, so divisor_count should return 4. The value of n will be at most 109.

Read the partially completed code in the editor and complete it. You just need to write the MyCalculator class only. Your class shouldn't be public.

Sample Input 0

6
Sample Output 0

I implemented: AdvancedArithmetic
4




import java.util.*;
interface AdvancedArithmetic{
  int divisor_sum(int n);
}

//BODY STARTS HERE
class MyCalculator implements AdvancedArithmetic {
    public int divisor_sum(int n) {
        int sum=0;
        for(int i=1;i<=n;i++){
            if(n%i==0)
                sum+=1;
        }
        return sum;
    }
}

//BODY ENDS HERE

class Solution{
    public static void main(String []args){
        MyCalculator my_calculator = new MyCalculator();
        System.out.print("I implemented: ");
        ImplementedInterfaceNames(my_calculator);
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.print(my_calculator.divisor_sum(n) + "\n");
      	sc.close();
    }
    /*
     *  ImplementedInterfaceNames method takes an object and prints the name of the interfaces it implemented
     */
    static void ImplementedInterfaceNames(Object o){
        Class[] theInterfaces = o.getClass().getInterfaces();
        for (int i = 0; i < theInterfaces.length; i++){
            String interfaceName = theInterfaces[i].getName();
            System.out.println(interfaceName);
        }
    }
}


OO 05 - Comparator Interface

Comparator interface is used to order the objects of user-defined classes. A comparator object is capable of comparing two objects of two different classes. Following function compares obj1 with obj2

Syntax:

public int compare(Object obj1, Object obj2):

Suppose we have an array/arraylist of our own class type, containing fields like rollno, name, address, DOB etc and we need to sort the array based on Roll no or name?

Method 1: One obvious approach is to write our own sort() function using one of the standard algorithms. This solution requires rewriting the whole sorting code for different criterion like Roll No. and Name.

Method 2: Using comparator interface- Comparator interface is used to order the objects of user-defined class. This interface is present java.util package and contains 2 methods compare(Object obj1, Object obj2) and equals(Object element). Using comparator, we can sort the elements based on data members. For instance it may be on rollno, name, age or anything else.

Method of Collections class for sorting List elements is used to sort the elements of List by the given comparator.

// To sort a given list. ComparatorClass must implement // Comparator interface.

public void sort(List list, ComparatorClass c)

How does Collections.Sort() work?

Internally the Sort method does call Compare method of the classes it is sorting. To compare two elements, it asks “Which is greater?” Compare method returns -1, 0 or 1 to say if it is less than, equal, or greater to the other. It uses this result to then determine if they should be swapped for its sort.

Your task is to write a comparator class that takes as argument two objects of type Point and sorts them first by their Y-coordinate and breaks ties by X-coordinate.
