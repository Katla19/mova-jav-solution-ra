
Domino Piles
Problem
Submissions
You are given a rectangular board of M × N squares. Also you are given an unlimited number of standard domino pieces of 2 × 1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1.Each domino completely covers two squares.

2.No two dominoes overlap.

3.Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.

Input Format

In a single line you are given two integers M and N — board sizes in squares

Constraints

1 ≤ M ≤ N ≤ 16

Output Format

Output one number — the maximal number of dominoes, which can be placed.

Sample Input 0

2 4
Sample Output 0

4


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
     
    int a,b,c;
        Scanner sc=new Scanner(System.in);
        a=sc.nextInt();
        b=sc.nextInt();
        if(b==1){
           System.out.println(a/2);
       
        }
        else{
            if(b%2==0){
                System.out.println(a*(b/2));
               
            }
            else{
                System.out.println((a*((b-1)/2))+a/2);
                }
        }
    }
}




Z 412 The Slopes of Line Segments
Problem
Submissions
In the town of line segments two line segments can only become friends if their slopes are equal. Line segments are not smart enough to calculate their own or some other line segment's slope so they use a machine called the slopeFinder to check their compatibility. Recently someone stole the slopeFinder and now the line segments are upset because they cannot make new friends. The Mayor of the town has hired you to write a code to fix the crisis that their town is facing.

Input Format

Input Contains two line segments each on a line of its own. Each line segment is denoted by four integers Xa, Ya, Xb and Yb where (Xa,Ya) and (Xb, Yb) denote the two end points of the line segment.

Constraints

0 <= |Xa|,|Xb|,|Ya|,|Yb| <= 100

Output Format

Output "yes" if both the line segments have the same slope and "no" otherwise. (without the quotes).

Sample Input 0

0 0 1 1
1 0 2 1
Sample Output 0

yes
Sample Input 1

0 0 1 1
2 1 3 0
Sample Output 1

no




import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int slope1=0,slope2=0;
        int xa1=in.nextInt();
        int ya1=in.nextInt();
        int xb1=in.nextInt();
        int yb1=in.nextInt();
        int xa2=in.nextInt();
        int ya2=in.nextInt();
        int xb2=in.nextInt();
        int yb2=in.nextInt();
        if(xa1!=xb1 && xa2!=xb2){
            slope1=(yb1-ya1)/(xb1-xa1);
            slope2=(yb2-ya2)/(xb2-xa2);
            if(slope1==slope2){
                System.out.println("yes");
            }
            else{
                System.out.println("no");
            }
   
           
           
        }
        else{
            if(xa1==xb1)slope1=1000;
            if(xa2==xb2)slope2=1000;
            if(slope1==slope2) System.out.println("yes");
            else System.out.println("no");
        }
    }
}





D M01 - Great Pattern
Problem
Submissions
Your task is simple, write a program in Java to print the following pattern :

N = 1
1

N = 2
  1
1 2 1
  1
  
N = 3
    1
  1 2 1
1 2 3 2 1
  1 2 1
    1
    
and so on..
INPUT
Input consists of many test cases.
First line contains the number of test case T.
Each of the test case lines consists of one number N for that test case.

OUTPUT
Print the pattern corresponding to the N value of each test case.
Print a blank line between two test case outputs.

CONSTRAINTS
1 ≤ T, N ≤ 10

Sample Input 0

3
1
2
3
Sample Output 0

1

  1
1 2 1
  1
  
    1
  1 2 1
1 2 3 2 1
  1 2 1
    1


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        while(t>0){
            int n=sc.nextInt();
            for(int i=1;i<=n;i++){
                for(int j=0;j<n-i;j++){
                    System.out.print("  ");
                }
                for(int j=1;j<=i;j++){
                  System.out.print(j+" ");
                }
               for(int j=i-1;j>=1;j--){
                     System.out.print(j+" ");
               }
                System.out.println();
            }
            for(int i=n-1;i>=1;i--){
                for(int j=1;j<=n-i;j++){
                     System.out.print("  ");
                }
               for(int j=1;j<=i;j++){
                   System.out.print(j+" ");
                }
                for(int j=i-1;j>=1;j--){
                    System.out.print(j+" ");
                }
                System.out.println();
             }
            System.out.println();
            t--;
        }
    }
}


Super Prime Number
Problem
Submissions
Hi! Itsa Me! aMario! While plumping my way through the town looking for my princess, I talked to a duck that told me about prime numbers. Apparently a prime number is a number that only has two divisors, i.e. 1 and itself. Interesting isnt it? Being the Super Mario that I am, I decided to come up with the concept of a super prime number. Formally, a super prime number is a number sum of all of whose divisors except itself is prime i.e. sum of every divisor of a number except itself being prime makes the number a super prime number. I have Q queries regarding super prime numbers. Each query is a number and I need to know if the number is super prime or not. Can you help me?

Input Format

First line contains the number of queries Q.
Next Q lines contain one integer each denoting the numbers associated with the queries.

Constraints

1 <= Q <= 10^5
1 <= queries <= 10^5

Output Format

For every query print YES if the number is a super prime number and print NO otherwise. Output must contain Q lines, each line containing the answer to one query.

Sample Input 0

4
4 5 9 8
Sample Output 0

YES
NO
NO
YES



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    static int SoD(int n){
           int sum=0;
            for (int i=1;i<=Math.sqrt(n);i++){
                if (n%i==0){
                    if (n/i == i)
                    sum=sum+i;
      
                else // Otherwise print both
                    sum=sum+i+(n/i);
                }
            }
           return (sum-n);
        }
    static boolean isPrime(int n)
    {
 
        // Check if number is less than
        // equal to 1
        if (n <= 1)
            return false;
 
        // Check if number is 2
        else if (n == 2)
            return true;
 
        // Check if n is a multiple of 2
        else if (n % 2 == 0)
            return false;
 
        // If not, then just check the odds
        for (int i = 3; i <= Math.sqrt(n); i += 2)
        {
            if (n % i == 0)
                return false;
        }
        return true;
    }
 

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int t=0;
        for(int i=0 ;i<n;i++){
            t=sc.nextInt();
            if(isPrime(SoD(t))){
                System.out.println("YES");
            }
            else{
                System.out.println("NO");
            }
        }
    }
}





T 131 - Confused Integer
Problem
Submissions
Our beloved integer X is confused. He was told that he is a positive integer which fits in a 32 bit signed integer that can be expressed as A^P where P > 1 and A > 0 where A and P both should be integers. Now he wonders, there is a possibility that he does not exist at all because he does not satisfy the A^P expressibility condition. Given the values of A and P, find out if X exists or not.

Input Format

Input contains the value of integer X.

Constraints

0 < X < 2x10^9

Output Format

Output "yes" if X can be expressed as A^P and "no" otherwise.

Sample Input 0

4
Sample Output 0

yes
Explanation 0

Yes as 2^2 = 4



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int flag=0;
        for(int i=0;i<=Math.sqrt(n);i++){
            for(int j=0;j<=Math.sqrt(n);j++){
                if((long)(Math.pow(i,j))==n){
                    flag=1;
                }
            }
        }
        if(flag==1){
            System.out.println("yes");
        }
        else{
            System.out.println("no");
        }
    }
}




G M04 - The Elite N
Problem
Submissions
The Elite N are a number of people in a line, that you have to beat in order to be the Pokémon Champion.
Each person has exactly one Pokémon, with a predetermined power level.
When a battle occurs, the powers of both Pokémon steadily decrease until either reaches 0. This will be referred to as fainting.
You have to make sure your Pokémon doesn't faint, i.e., its power should remain > 0
You can take rest and restore your Pokémon to full power to start battling again. But it takes one day to do so.
When you rest the current opponent also takes a rest restoring his powers to full.
You can fight as many battles as possible in a day until you rest.
Find the number of days you will need to defeat the Elite N and become the champion.
Note that there might be a person stronger than you whom you cannot defeat. Hence you will have to lose.
Print the number of days required to defeat the Elite N, and -1 if you can't.
Input Format

The first line of input contains your Pokémon's power, K. The second line contains the number of opponents, N. The next line contains n numbers A1, A2 ... An, where Ai is the power of the ith opponent.

Constraints

1 <= k <= 1000

1 <= n <= 100000

1 <= a1, a2, a3, ..., an <= 1000

Output Format

Output only one number, the number of days taken to defeat the Elite N.

Sample Input

10

7

1 2 4 7 2 5 5

Sample Output

4

Explanation

On the first day you defeat 1st, 2nd and 3rd opponent. As the remaining power would be 3, you can't battle the 4th one. So you take rest. On the 2nd day, you defeat the 4th and the 5th opponent, then take rest. On the 3rd day, you defeat the 6th enemy only. As you cannot let your pokemon faint, you will have to take rest. On the 4th day you defeat the last of the Elite N and become the champion! :D




import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int k=sc.nextInt();
        int n=sc.nextInt();
        int po,current=k,l=1,m=0;
        for(int i=0;i<n;i++){
            po=sc.nextInt();
            if(k<=po){
                m=1;
            }
            if(po>=current){
                l++;
                current=k;
            }
            current=current-po;
        }
        if(current==0){
            l++;
        }
        if(m==0){
            System.out.println(l);
        }
        else{
            System.out.println("-1");
        }
    }
}



B D01 - Find The Coders DayB D01
Day of the Programmer
Marie invented a Time Machine and wants to test it by time-traveling to visit Russia on the Day of the Programmer (the 256th day of the year) during a year in the inclusive range from 1700 to 2700.

From 1700 to 1917, Russia's official calendar was the Julian calendar; since 1919 they used the Gregorian calendar system. The transition from the Julian to Gregorian calendar system occurred in 1918, when the next day after January 31st was February 14th. This means that in 1918, February 14th was the 32nd day of the year in Russia.

In both calendar systems, February is the only month with a variable amount of days; it has 29 days during a leap year, and 28 days during all other years. In the Julian calendar, leap years are divisible by 4; in the Gregorian calendar, leap years are either of the following:

Divisible by 400.
Divisible by 4 and not divisible by 100.
Given a year, , find the date of the 256th day of that year according to the official Russian calendar during that year. Then print it in the format dd.mm.yyyy, where dd is the two-digit day, mm is the two-digit month, and yyyy is .

For example, the given  = 1984. 1984 is divisible by 4, so it is a leap year. The 256th day of a leap year after 1918 is September 12, so the answer is .

Function Description

Complete the dayOfProgrammer function in the editor below. It should return a string representing the date of the 256th day of the year given.

dayOfProgrammer has the following parameter(s):

year: an integer
Input Format

A single integer denoting year .

Constraints

1700 \le y \le 2700
Output Format

Print the full date of Day of the Programmer during year  in the format dd.mm.yyyy, where dd is the two-digit day, mm is the two-digit month, and yyyy is .

Sample Input 0

2017
Sample Output 0

13.09.2017
Explanation 0

In the year  = 2017, January has 31 days, February has 28 days, March has 31 days, April has 30 days, May has 31 days, June has 30 days, July has 31 days, and August has 31 days. When we sum the total number of days in the first eight months, we get 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 = 243. Day of the Programmer is the 256th day, so then calculate 256 - 243 = 13 to determine that it falls on day 13 of the 9th month (September). We then print the full date in the specified format, which is 13.09.2017.

Sample Input 1

2016
Sample Output 1

12.09.2016
Explanation 1

Year  = 2016 is a leap year, so February has 29 days but all the other months have the same number of days as in 2017. When we sum the total number of days in the first eight months, we get 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 = 244. Day of the Programmer is the 256th day, so then calculate 256 - 244 = 12 to determine that it falls on day 12 of the 9th month (September). We then print the full date in the specified format, which is 12.09.2016.

Sample Input 2

1800
Sample Output 2

12.09.1800
Explanation 2

Since 1800 is leap year as per Julian calendar. Day lies on 12 September.

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int year=sc.nextInt();
        if(year<=1918){
            if(year==1918){
                System.out.println("26.09.1918");
            }
            else{
                if(year%4==0){
                    System.out.println("12.09."+year);
                }
                else{
                    System.out.println("13.09."+year);
                }
            }
        }
        else{
            if((year%400==0)||((year%4==0)&&(year%100!=0))){
                    System.out.println("12.09."+year);
                }
                else{
                    System.out.println("13.09."+year);
                }
        }
        
    }
}




C D09 - To and Fro
Problem
Submissions
A futuristic company is building an autonomous car. The scientists at the company are training the car to perform Reverse parking. To park, the car needs to be able to move in backward as well as forward direction. The car is programmed to move backwards B meters and forwards again, say F meters, in a straight line. The car does this repeatedly until it is able to park or collides with other objects. The car covers 1 meter in T units of time. There is a wall after distance D from car's initial position in the backward direction.

The car is currently not without defects and hence often hits the wall. The scientists are devising a strategy to prevent this from happening. Your task is to help the scientists by providing them with exact information on amount of time available before the car hits the wall.

Input Format:

First line contains total number of test cases, denoted by N Next N lines, contain a tuple containing 4 values delimited by space F B T D, where 1. F denotes forward displacement in meters 2. B denotes backward displacement in meters 3. T denotes time taken to cover 1 meter 4. D denotes distance from Car's starting position and the wall in backward direction

Output Format:

For each test case print time taken by the Car to hit the wall

Constraints:
First move will always be in backward direction
1 <= N <= 100
backward displacement > forward displacement i.e. (B > F)
forward displacement (F) > 0
backward displacement (B) > 0
time (T) > 0
distance (D) > 0
All input values must be positive integers only

Sample Input 0

2
6 9 3 18
3 7 5 20
Sample Output 0

162
220




import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        while(n!=0){
            int f=sc.nextInt();
            int d=sc.nextInt();
            int c=sc.nextInt();
            int dist=sc.nextInt();
            int b=0;
            while(dist>d){
                b=b+d+f;
                dist=dist-d+f;
            }
            b=b+dist;
            System.out.println(b*c);
            n--;
        }
    }
}


B D06 - Prime Series
Problem
Submissions
Identify and print the following pattern generated by prime numbers for a given N.

N = 1
2

N = 2
2
3 5

N = 3
2
3 5
7 11 13
Input
Input consists of a single integer N

Output
Output must consists of the pattern as shown above.

Sample Input 0

3
Sample Output 0

2
3 5
7 11 13


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int m=sc.nextInt();
        int ct=0,n=0,i=1,j=1;
        int[] a=new int[m*(m+1)/2];
        while(n<m*(m+1)/2){  
            j=1;  
            ct=0;  
            while(j<=i){  
                if(i%j==0)  
                    ct++;  
                j++;   
            }  
            if(ct==2){  
                a[n]=i;  
                n++;  
            }      
            i++;  
        }  
        n=0;
        for(i=0;i<m;i++){
            for(j=0;j<i+1;j++){
                System.out.print(a[n]+" ");
                n++;
            }
            System.out.println();
        }
    }
}






Given an array of integers, replace every element with the greatest element on the right side in the array. Replace last element with 0 as there no element on the right side of it.

Input Format

First line contains N , the number of Numbers. Next line contains N integers a[1]..a[n] the numbers

Constraints

1<= N <= 10^5
1<= ai <= 10^5

Output Format

Print the array required

Sample Input 0


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[] a=new int[n];
        int[] b=new int[n];
        for(int i=0;i<n;i++){
            a[i] = sc.nextInt();   
        }
        int max=a[n-1];
        b[n-1]=0;
        b[n-2]=max;
        for(int i=2;i<n;i++){
            if(a[n-i]>max){
                max=a[n-i];
                b[n-i-1]=max;
            }
            else{
                b[n-i-1]=max;
            }
        }
        for(int i=0;i<n;i++){
            System.out.print(b[i]+" ");
        }
    }
}




As simple as the title, given a number N, print the number of digits in N!

N! is defined as : N! = 1*2*3...(N-1)*N

0! = 0 and 1! = 1.

No number ever contains any leading zeros.

Input Format

Input contains only one number, N.

Constraints

1 <= N <= 1000

Output Format

Output one number that is equal to the number of digits in N!

Sample Input 0

6
Sample Output 0

3
Explanation 0

6! = 1x2x3x4x5x6 = 720 which has 3 digits. So the answer is 3.




import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        double k=0;
        for(int i=2;i<n+1;i++){
            k+=Math.log10(i);
        }
        System.out.println((int)k+1);
    }
}



Using inheritance, one class can acquire the properties of others. Consider the following HumanBeing class.

class HumanBeing{
    void eat(){
        System.out.println("I am eating");
    }
}
The class has only one method, eat. Next, we want to create another Teenager class that also has the beArrogant method. We can do this using the extends keyword :

class Teenager extends HumanBeing {
    void beArrogant() {
        System.out.println("I am being arrogant");
    }
}
Finally, we can create a Teenager object that can both eat and be arrogant at the same time.

public class Solution{
   public static void main(String[] args){

      Teenager teen = new Teenager();
      teen.eat();
      teen.beArrogant();
   }
}
The above code will print :

I am eating
I am being arrogant
This means that a Teenager object has all the properties that a HumanBeing object has, as well as some additional unique properties.

The code above is provided for you in your editor. You must add a reasonlessRebel method to the Teenager class, so that the code prints the following lines:

I am eating
I am being arrogant
I am a rebel
NOTE :
Do not make any changes to the head or the tail of the code


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

class HumanBeing{
	void eat(){
		System.out.println("I am eating");
	}
}

//BODY OF THE CODE BEGINS HERE
class Teenager extends HumanBeing{
	void beArrogant(){
		System.out.println("I am being arrogant");
	}
}
//BODY OF THE CODE ENDS HERE


public class Solution{

   public static void main(String args[]){
	  Teenager teen = new Teenager();
	  teen.eat();
	  teen.beArrogant();
      teen.reasonlessRebel();
   }
}







OO 02 - Basics of Inheritance - II
Problem
Submissions
Write the code for the following in the editor below :

A class named Arithmetic with a method named multiply that takes as parameters two integers and returns their product.
A class named Multiplier that inherits from the superclass named Arithmetic.
Your classes should be public.

Input Format

You are not responsible for reading any input from stdin; a code stub will test your submission by calling the multiply method on a Multiplier object and passing it 2 integer parameters.

You only need to write the code for the Arithmetic class and the Multiplier class

Output Format

You are not responsible for printing anything to stdout. Your multiply method must return the product of its parameters.

Sample Output :
The main method in the Solution class above should print the following:

My superclass is: Arithmetic
50 100 200





import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

//BODY BEGINS HERE
class Arithmetic{
    public int multiply(int a,int b){
        return(a*b);
    }
}
class Multiplier extends Arithmetic{
    public int demultiply(int a,int b){
        return(multiply(a,b));
    
    }
}



//BODY ENDS HERE

public class Solution{
    public static void main(String []args){
        // Create a new Multiplier object
        Multiplier a = new Multiplier();
        
        // Print the name of the superclass on a new line
        System.out.println("My superclass is: " + a.getClass().getSuperclass().getName());	
        
        // Print the result of 3 calls to Multiplier's `multiply(int,int)` method as 3 space-separated integers:
        System.out.print(a.multiply(5,10) + " " + a.multiply(10,10) + " " + a.multiply(20,10) + "\n");
     }
}





In Java an abstract class is a class that may or may not have abstract functions.

Abstract classes cannot be initiated directly because they may contain functions that lack implementation.

Similarly, abstract functions are those functions that do not have an implementation.

To initiate abstract classes, one must inherit them to another class and write the implementations for the abstract functions in order to use them.

In the current problem you are given an abstract class as follows :

abstract class Arithmetic
{
    abstract int add(int, int);
    abstract int subtract(int, int);
    abstract int divide(int, int);
    abstract int multiply(int, int);
}
Your task is to write a new class called Calculator that inherits the class Arithmetic and implement all its functions.

NOTE:
You are only allowed to edit the body of the code.

Input Format

You are not responsible for any form of input or output.
Your only task is to implement the Calculator class.



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

abstract class Arithmetic
{
  abstract int add(int x, int y);
  abstract int subtract(int x, int y);
  abstract int multiply(int x, int y);
  abstract int divide(int x , int y);
}

//BODY STARTS HERE

class Calculator extends Arithmetic{
  
        int add(int a,int b){
            return (a+b);
        }
        int subtract(int a,int b){
            return (a-b);
        }
        int multiply(int a,int b){
            return (a*b);
        }
        int divide(int a,int b){
            return (a/b);
        }
}
//BODY ENDS HERE


public class Solution{
  public static void main(String args[])
  {
    Calculator cal = new Calculator();
   	int A = 10, B = 5;
   	System.out.println("Addition Result : " + cal.add(A, B));
    System.out.println("Subtraction Result : " + cal.subtract(A, B));
    System.out.println("Multiplication Result : " + cal.multiply(A, B));
    System.out.println("Division Result : " + cal.divide(A, B));
  }
}



A Java interface can only contain method signatures and fields. The interface can be used to achieve polymorphism. In this problem, you will practice your knowledge on interfaces.

You are given an interface AdvancedArithmetic which contains a method signature int divisor_count(int n). You need to write a class called MyCalculator which implements the interface.

divisor_count function just takes an integer as input and return the total number of its divisors. For example divisors of 6 are 1, 2, 3 and 6, so divisor_count should return 4. The value of n will be at most 109.

Read the partially completed code in the editor and complete it. You just need to write the MyCalculator class only. Your class shouldn't be public.

Sample Input 0

6
Sample Output 0

I implemented: AdvancedArithmetic
4




import java.util.*;
interface AdvancedArithmetic{
  int divisor_sum(int n);
}

//BODY STARTS HERE
class MyCalculator implements AdvancedArithmetic {
    public int divisor_sum(int n) {
        int sum=0;
        for(int i=1;i<=n;i++){
            if(n%i==0)
                sum+=1;
        }
        return sum;
    }
}

//BODY ENDS HERE

class Solution{
    public static void main(String []args){
        MyCalculator my_calculator = new MyCalculator();
        System.out.print("I implemented: ");
        ImplementedInterfaceNames(my_calculator);
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.print(my_calculator.divisor_sum(n) + "\n");
      	sc.close();
    }
    /*
     *  ImplementedInterfaceNames method takes an object and prints the name of the interfaces it implemented
     */
    static void ImplementedInterfaceNames(Object o){
        Class[] theInterfaces = o.getClass().getInterfaces();
        for (int i = 0; i < theInterfaces.length; i++){
            String interfaceName = theInterfaces[i].getName();
            System.out.println(interfaceName);
        }
    }
}


OO 05 - Comparator Interface

Comparator interface is used to order the objects of user-defined classes. A comparator object is capable of comparing two objects of two different classes. Following function compares obj1 with obj2

Syntax:

public int compare(Object obj1, Object obj2):

Suppose we have an array/arraylist of our own class type, containing fields like rollno, name, address, DOB etc and we need to sort the array based on Roll no or name?

Method 1: One obvious approach is to write our own sort() function using one of the standard algorithms. This solution requires rewriting the whole sorting code for different criterion like Roll No. and Name.

Method 2: Using comparator interface- Comparator interface is used to order the objects of user-defined class. This interface is present java.util package and contains 2 methods compare(Object obj1, Object obj2) and equals(Object element). Using comparator, we can sort the elements based on data members. For instance it may be on rollno, name, age or anything else.

Method of Collections class for sorting List elements is used to sort the elements of List by the given comparator.

// To sort a given list. ComparatorClass must implement // Comparator interface.

public void sort(List list, ComparatorClass c)

How does Collections.Sort() work?

Internally the Sort method does call Compare method of the classes it is sorting. To compare two elements, it asks “Which is greater?” Compare method returns -1, 0 or 1 to say if it is less than, equal, or greater to the other. It uses this result to then determine if they should be swapped for its sort.

Your task is to write a comparator class that takes as argument two objects of type Point and sorts them first by their Y-coordinate and breaks ties by X-coordinate.





import java.util.*;
import java.lang.*;
import java.io.*;

class Point
{
    public int x;
    public int y;
    public Point(int _x, int _y)
    {
        x = _x;
        y = _y;
    }
}

//BODY STARTS HERE

class sortByX implements Comparator<Point>
{
    public int compare(Point a,Point b){
    if(a.y>b.y)
    return 1;
    else if(a.y==b.y&&a.x>b.x)
    return 1;
    else
    return -1;
    }
}

//BODY ENDS HERE

public class Solution
{
    public static void main (String[] args)
    {
        // your code goes here
        ArrayList<Point> ar = new ArrayList<Point>();
        ar.add(new Point(1,1));
        ar.add(new Point(1,2));
        ar.add(new Point(2,2));
        ar.add(new Point(2,1));
        
        Collections.sort(ar, new sortByX());
        
        for (int i = 0; i < 4; i++)
        {
            System.out.println(ar.get(i).x + " " + ar.get(i).y);
        }
    }
}





OO 06 - Method Overriding in Java
Problem
Submissions
When a subclass inherits from a superclass, it also inherits its methods; however, it can also override the superclass methods (as well as declare and implement new ones). Consider the following Disney class:

class DisneyCharacter{
    String getName(){
        return "Anonymous Disney Character";
    }
    String getPantsState(){
        return "I may or may not be wearing pants";
    }
}
Next we create a DonaldDuck class that inherits from the DisneyCharacter class. We can override the getName() function and return a different sub-class specific string.

class DonaldDuck extends DisneyCharacter{
    @Override
    String getName(){
        return "Donald Duck";
    }
}
Note: When overriding a method, you should precede it with the @Override annotation. The parameter(s) and return type of an overridden method must be exactly the same as those of the method inherited from the supertype.

Task :
Complete the code in your editor by writing an overridden getPantsState method that returns a string just as the superclass' getPantsState method, except that it replaces with "I wear pants" or "I do not wear pants" based on the character.

Your task is to make two character classes, DonaldDuck and MickeyMouse and have them two overridden methods each.

Output Format :
When executed your code must print the following :

Anonymous Disney Character
I may or may not be wearing pants
DonaldDuck
I do not wear pants
MickeyMouse
I wear pants





import java.util.*;
class DisneyCharacter{
    String getName(){
        return "Anonymous Disney Character";
    }
    String getPantsState(){
        return "I may or may not be wearing pants";
    }
}
class DonaldDuck extends DisneyCharacter{
    @Override
    String getName(){
        return "DonaldDuck";
    }
    String getPantsState(){
        return "I do not wear pants";
    }
}
class MickeyMouse extends DisneyCharacter{
    @Override
    String getName(){
        return "MickeyMouse";
    }
    String getPantsState(){
        return "I wear pants";
    }
}



public class Solution{
    
    public static void main(String []args){
          DisneyCharacter c0 = new DisneyCharacter();
        DonaldDuck c1 = new DonaldDuck();
        MickeyMouse c2 = new MickeyMouse();
        System.out.println(c0.getName());
        System.out.println(c0.getPantsState());
        System.out.println(c1.getName());
        System.out.println(c1.getPantsState());
        System.out.println(c2.getName());
        System.out.println(c2.getPantsState());
    }
}



OO 07 - The Super Keyword
Problem
Submissions
When a method in a subclass overrides a method in superclass, it is still possible to call the overridden method using super keyword. If you write super.func() to call the function func(), it will call the method that was defined in the superclass.

You are given a partially completed code in the editor. Modify the code so that the code prints the following text:

Hello I am a motorcycle, I am a cycle with an engine.
My ancestor is a cycle who is a vehicle with pedals.


import java.util.*;
import java.io.*;

class BiCycle{
    String define_me(){
        return "a vehicle with pedals.";
    }
}

class MotorCycle extends BiCycle{
    String define_me(){
        return "a cycle with an engine.";
    }
    
    MotorCycle(){
        System.out.println("Hello I am a motorcycle, I am "+ define_me());

        String temp=super.define_me(); //Fix this line
        System.out.println("My ancestor is a cycle who is "+ temp );
    }
    
}
class Solution{
    public static void main(String []args){
        MotorCycle M=new MotorCycle();
    }
}



OO 08 - InstanceOf Keyword
Problem
Submissions
The Java instanceof operator is used to test if the object or instance is an instanceof the specified type.

In this problem we have given you three classes in the editor:

Student Class

Rockstar Class

Hacker Class

In the main method, we populated an ArrayList with several instances of these classes. count method calculates how many instances of each type is present in the ArrayList. The code prints three integers, the number of instance of Student class, the number of instance of Rockstar class, the number of instance of Hacker class.

But some lines of the code are missing, and you have to fix it by modifying only lines! Don't add, delete or modify any extra line.

To restore the original code in the editor, click on the top left icon in the editor and create a new buffer.

Sample Input 0

5
Student
Student
Rockstar
Student
Hacker
Sample Output 0

3 1 1



import java.util.*;


class Student{}
class Rockstar{}
class Hacker{}


public class InstanceOFTutorial{
   
   static String count(ArrayList mylist){
      int a = 0,b = 0,c = 0;
      for(int i = 0; i < mylist.size(); i++){
         Object element=mylist.get(i);
         if(element instanceof Student)
            a++;
         if(element instanceof Rockstar)
            b++;
         if(element instanceof Hacker)
            c++;
      }
      String ret = Integer.toString(a)+" "+ Integer.toString(b)+" "+ Integer.toString(c);
      return ret;
   }

   public static void main(String []args){
      ArrayList mylist = new ArrayList();
      Scanner sc = new Scanner(System.in);
      int t = sc.nextInt();
      for(int i=0; i<t; i++){
         String s=sc.next();
         if(s.equals("Student"))mylist.add(new Student());
         if(s.equals("Rockstar"))mylist.add(new Rockstar());
         if(s.equals("Hacker"))mylist.add(new Hacker());
      }
      System.out.println(count(mylist));
   }
}



OO 09 - Iterator in Java
Problem
Submissions
Java Iterator class can help you to iterate through every element in a collection. Here is a simple example:

import java.util.*;
public class Example{

    public static void main(String []args){
        ArrayList mylist = new ArrayList();
        mylist.add("Hello");
        mylist.add("Java");
        mylist.add("4");
        Iterator it = mylist.iterator();
        while(it.hasNext()){
            Object element = it.next();
            System.out.println((String)element);
        }
    }
}
In this problem you need to complete a method func. The method takes an ArrayList as input. In that ArrayList there is one or more integer numbers, then there is a special string "###", after that there are one or more other strings. A sample ArrayList may look like this:

element[0]=>42
element[1]=>10
element[2]=>"###"
element[3]=>"Hello"
element[4]=>"Java"
You have to modify the func method by editing at most 2 lines so that the code only prints the elements after the special string "###". For the sample above the output will be:

Hello
Java
Note: The stdin doesn't contain the string "###", it is added in the main method.

To restore the original code in the editor, click the top left icon on the editor and create a new buffer.



import java.util.*;
public class Main{
   
   static Iterator func(ArrayList mylist){
      Iterator it=mylist.iterator();
      while(it.hasNext()){
         Object element = it.next();
         if(element instanceof String)//Hints: use instanceof operator
            break;
      }
      return it;
      
   }
   @SuppressWarnings({ "unchecked" })
   public static void main(String []args){
      ArrayList mylist = new ArrayList();
      Scanner sc = new Scanner(System.in);
      int n = sc.nextInt();
      int m = sc.nextInt();
      for(int i = 0;i<n;i++){
         mylist.add(sc.nextInt());
      }
      
      mylist.add("###");
      for(int i=0;i<m;i++){
         mylist.add(sc.next());
      }
      
      Iterator it=func(mylist);
      while(it.hasNext()){
         Object element = it.next();
         System.out.println((String)element);
      }
   }
}


Z 403 Sum of all Digits
Problem
Submissions
You are given an integer I in the following format :
You are given two integers P and Q.
Integer I can be obtained by appending Q instances of P together.
For example, if P = 619 and Q = 4, then I = 619619619619.

Your task is, given P and Q find the sum of all the digits of I.
That sounds too simple, so lets take it up a notch.
Lets say the sum of all digits is S, then run the following pseudocode :

int SumOfDigits(S) :
	K <- Sum of Digits of S
    if K is a single digit number, return K
    else return SumOfDigits(K)
INPUT
Input consist of two numbers P and Q separated by a space.

OUTPUT
Print a single digit, the final digit when the numbers of I are continuously added.

CONSTRAINTS
1 ≤ P ≤ 10100000
**1 ≤ Q ≤ **105

Sample Input 0

148 3
Sample Output 0

3




Language: Python 3
def sup_digits(x,k):
    a = digsum(x)
    return sup_digit(str(int(a)*k))

def sup_digit(x):
    if len(x) <= 1:
        return x
    else:
        return sup_digit( digsum(x) )

def digsum(x):
    return str(sum((int(i) for i in list(x))))


n, k = input().split()
print( sup_digits(n, int(k)))






I M05 - Minimize Waste Cells
Problem
Submissions
Previously, it was important for every company to have a motto.

Now, it is important for every company to have a banner.

Since companies want to save their resources, they decided to convert their motto into a banner.

How this works is, you create a square matrix of size N x N, and fill in the elements of this matrix using the motto in row-major order.

The remaining spaces in the matrix are called waste cells and are to be represented as '?'.

You have to choose N in such a way that the number of waste cells is minimized.

Input
Input consists of one line only, containing the company motto

Output
Output must consist of the matrix formed from the input string

Notes
The length of the input string will not exceed 1000

Sample Input 0

nike - just do it!
Sample Output 0

nike 
- jus
t do 
it!??
?????
Sample Input 1

oneplus - never settle!
Sample Output 1

onepl
us - 
never
 sett
le!??


Python 3
def function(st, k):
    a = len(st)+1
    for i in range(a,(k*k)+1):
        st = st[:i] + "?" + st[i:]
    for i in range(len(st)): 
        if i%k == 0: 
            sub = st[i:i+k] 
            lst = []
            for j in sub:
                lst.append(j)
            print(''.join(lst))
            
s = input()
length = len(s)
if(length == 1):
    print(s)
else:
    if(length == 2):
        s = s[:3]+"?"+s[3:]
        length = len(s)
    for i in range(2,length):
        if ( (i*i) >= length):
            jen = i
            break
    function(s, jen)




B D05 - Consecutive Prime Sum
Problem
Submissions
Some prime numbers can be expressed as Sum of other consecutive prime numbers.

For example

5 = 2 + 3
17 = 2 + 3 + 5 + 7
41 = 2 + 3 + 5 + 7 + 11 + 13

Your task is to find out how many prime numbers which satisfy this property are present in the range 3 to N subject to a constraint that summation should always start with number 2.

Write code to find out number of prime numbers that satisfy the above mentioned property in a given range.

Input Format:
Each test case contains a number N <= 1000000000

Output Format:
Print the total number of all such prime numbers which are less than or equal to N.


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    
    public static boolean isPrime(int n)
    {
        if(n==2)
            return true;
        if(n%2==0)
            return false;
        for(int i=3;i<=Math.sqrt(n);i++)
        {
            if(n%i==0)
                return false;
        }
        return true;
    }

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k=3;
        int sum=2;
        int count=0;
            while(true)
            {
                if(isPrime(k))
                {
                    sum=sum+k;
                    if(sum>=n)
                        break;
                    if(isPrime(sum))
                        count++;
                }
                k++;
            }
        System.out.println(count);
    }
}



Z 401 The Permutation Problem
Problem
Submissions
You are given an array of N integers which is a permutation of the first N natural numbers. You can swap any two elements of the array. You can make at most K swaps. What is the largest permutation, in numerical order, you can make?

Input Format

The first line of the input contains two integers, N and K, the size of the input array and the maximum swaps you can make, respectively. The second line of the input contains a permutation of the first N natural numbers.

Constraints

1≤N≤10^5 1≤K≤10^9

Output Format

Print the lexicographically largest permutation you can make with at most K swaps

Sample Input 0

5 1
4 2 3 5 1
Sample Output 0

5 2 3 4 1



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        int[] arr=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        //int p=0;
        if(k>n){
            k=n;
        }
        for(int i=0;i<k;i++){
            for(int j=i+1;j<n;j++){
                if(arr[i]<arr[j]){
                    int temp=arr[i];
                    arr[i]=arr[j];
                    arr[j]=temp;
                }
            }
        }
        for(int i=0;i<n;i++){
            System.out.print(arr[i]+" ");
        }
    }
}



I M11 - Special Chemical Element
Problem
Submissions
Toyland unlike Earth has only 26 chemical elements known as of now. Each element is identified as a lowercase English letter in range ‘a’ - ‘z’. Every chemical compound is composed of these given chemical elements only. A chemical element is special if it is present in all the given compounds.

You are given a list of N chemical compounds. Print the number of special chemical elements.

Input Format

First line represent the integer N, number of chemical compounds. Next N lines contains chemical composition of each of the compound, consisting of lowercase english letter (‘a’ - ‘z’).

Constraints

1 ≤ N ≤ 100 1 ≤ length of composition of chemical compound ≤ 100

Output Format

Print the number of special chemical elements

Sample Input 0

4
abbbc
xbady
bghla 
aba
Sample Output 0

2


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
import java.lang.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int c2=0,c1=0;
        String a[]=new String[n];
        for(int i=0;i<n;i++) a[i]=sc.next();
        for(char c='a';c<='z';c++){
            c1=0;
            for(String s:a){
                //System.out.print(s);
                if(s.contains(Character.toString(c))) c1++;
                    
            }
            if(c1==n)c2++;
        }
        System.out.print(c2);
        
    }
}


Mystery of the Repeated Number
Problem
Submissions
Given an array consisting of n elements, every element except one occurs only once. Find out the element that occurs more than once.

Input Format

First line contains the number N, denoting the size of the array. Next line contains N integers, the array a[N].

Constraints

1 <= N <= 10000
1 <= a[i] <= 10000

It is guaranteed that all elements but one occur only once and exactly one element is repeated, i.e. it occurs twice. Print this repeated number.

Output Format

Print one number, which occurs twice in the array.

Sample Input 0

5
2 6 5 4 2
Sample Output 0

2

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[] arr=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                if(arr[i]==arr[j]){
                    System.out.println(arr[i]);
                    return ;
                }
            }
        }
    }
}




T 104 : Make Palindrome By Reversing
Problem
Submissions
Write a code that does the following :

iterations = 0
number = input()
while iterations < 5:
    number = number + number.reverse()
    if number is palindrome : 
        print number
        print "YES"
    iterations++;
print "NO"
Input Format

One number N.

Constraints

1 <= N <= 10^5

Output Format

One number, the final palindrome if possible then YES. If not possible then only a NO.

Sample Input 0

32
Sample Output 0

55
YES
Explanation 0

32 + 23 = 55 which is a palindrome

Sample Input 1

39
Sample Output 1

363
YES
Explanation 1

39 + 93 = 132 132 + 231 = 363 which is a palindrome


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    
    public static int palindrome(int num){
        int temp=num;
        int val=0;
        while(temp!=0){
                int r=temp%10;
                val=val*10+r;
                temp=temp/10;
            }
        return num+val;
    }

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int num=sc.nextInt();
        int i=0;
        int v=0;
        int count=0;
        while(i<5){
            num=palindrome(num);
            int temp=num;
            int value=0;
            while(temp!=0){
                int r=temp%10;
                value=value*10+r;
                temp=temp/10;
            }
            if(value==num){
                count=1;
                v=num;
                break;
            }
            i++;
        }
        if(count==1){
            System.out.println(v);
            System.out.println("YES");
        }
        else{
            System.out.println("NO");
        }
    }
}



Z 414 Minimum Number Function  /*Google Search question*/

Python 3


n = int(input())
ans = "int"
for i in range(n-1):
    ans = "min(int, " + ans + ")"
print(ans)


F M05 - Happy Sighting
Problem
Submissions
There are n pictures delivered for the new exhibition. The i-th painting has beauty ai. We know that a visitor becomes happy every time he passes from a painting to a more beautiful one.

We are allowed to arranged pictures in any order. What is the maximum possible number of times the visitor may become happy while passing all pictures from first to last. In other words, we are allowed to rearrange elements of array a in any order. What is the maximum possible number of indices i (1 <= i <= n - 1), such that ai + 1 > ai.

Input Format

The first line of the input contains integer n — the number of painting.

The second line contains the sequence a1, a2, ..., an, where ai means the beauty of the i-th painting.

Constraints

1 <= n <= 1000
1 <= ai <= 1000

Output Format

Print one integer — the maximum possible number of neighbouring pairs, such that ai + 1 > ai, after the optimal rearrangement.

Sample Input 0

4
200 100 100 200
Sample Output 0

2
Explanation 0

Sample Ordering that gives answer 2 :

100 200 100 200

C++

#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include <stdio.h>

using namespace std;
int a[1005];
int b[1005];
int tag[1005];
int tag2[1005];
int num[1005];
int n;
int main()
{
    scanf("%d",&n);
    memset(tag2,0,sizeof(tag2));
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        if(!tag2[a[i]])
        {
            tag2[a[i]]=1;
            b[++cnt]=a[i];
        }
    }
    sort(b+1,b+cnt+1);
    for(int i=1;i<=cnt;i++)
        tag[b[i]]=i;
    memset(num,0,sizeof(num));
    for(int i=1;i<=n;i++)
        num[tag[a[i]]]++;
    int ans=0;
    for(int i=1;i<=cnt;i++)
    {
        for(int j=i-1;j>=1;j--)
        {
                if(num[j]<=num[i])
                {
                    ans+=num[j];
                    num[j]=0;
                    num[i]-=num[j];
                }
                else
                {
                    ans+=num[i];
                    num[i]=0;
                    num[j]-=num[i];

                }
        }

    }
    printf("%d",ans);
    return 0;

}




Farmers and Cows
Problem
Submissions
In a village,there are n farmers. Each farmer has a certain number of cows. You have to find the number of triplets of farmers such that the number of cows of one farmer is the sum of the cows of other two farmers.

Input Format

Input contains n followed by n space separeted integers.
Output should contain the number of triplets.

Constraints

1 <= n <= 5000
1 <= a[i] <= 10^9
It is guaranteed that no two farmers have the same no. of cows.

Output Format

Output the number of satisfying triplets.

Sample Input 0

5
1 2 3 4 5
Sample Output 0

4



import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int[] arr=new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        int count=0;
        
        Arrays.sort(arr);
        for(int i=0;i<n-1;i++){
            int sum=0;
            for(int p=i+1;p<n;p++){
                sum=arr[i]+arr[p];
                if(Arrays.binarySearch(arr,sum)>=0){
                    count++;
                }
            }
        }
            
        System.out.println(count);
    }
}




The Conjuring 3
Problem
Submissions
Little Leya is scared because she has seen a ghost in her house. She lives in a strange house where there are no crosses so she cannot scare the ghosts off. Luckily she also knows that ghosts are scared of numbers that are some non negative power of 2. She has a number in her hand and wants to find out if she can use this number to scare off ghosts. Help her find out if the number can be used by Leya.

Input Format

Input Contains one number N.

Constraints

1 <= N <= 1e100

Output Format

Output "yes" if N is a direct power of 2 and "no" otherwise.

Sample Input 0

128
Sample Output 0

yes



import java.io.*;
import java.util.*;
import java.math.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner s=new Scanner(System.in);
        BigInteger n=new BigInteger(s.next());
        if(n.bitCount()==1)
            System.out.println("yes");
        else
            System.out.println("no");
    }
}




Z 431 PaneerLove
Problem
Submissions
Chappu is addicted to Paneer! Nikau wants to keep her happy for n days. In order to be happy in i-th day, she needs to eat exactly a[i] kilograms of Paneer.

There is a big shop uptown and Nikau wants to buy Paneer for her from there. In i-th day, they sell Paneer for pi dollars per kilogram.

Nikau knows all numbers a1,...,an and p1,...,pn. In each day, he can buy arbitrary amount of Paneer, also he can keep some Paneer he has for the future.

Nikau is a little tired from cooking Paneer, so he asked for your help. Help him to minimize the total money he spends to keep Chappu happy for n days.

Input Format

The first line of input contains integer n (1<=n<=10^5), the number of days.

In the next n lines, i-th line contains two integers ai and pi (1<=ai, pi<=100), the amount of Paneer Chappu needs and the cost of Paneer in that day.

Constraints

1 <= n <= 10^5

Output Format

Print the minimum money needed to keep Chappu happy for n days, in one line.

Sample Input 0

3
1 3
2 2
3 1
Sample Output 0

10

C

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

int main() {
 int n;    scanf("%d",&n);
    int a[n],p[n];
    int i;
    for(i=0;i<n;i++)    { 
        scanf("%d %d",&a[i],&p[i]);    }  
    i=0;    while(i<n-1)    {
        if(p[i]<p[i+1])        {
            p[i+1]=p[i];        } 
        i++;    }    
    int min=0;    
    for(i=0;i<n;i++)    {
        min=min+a[i]*p[i];       }
    printf("%d",min);                  
    return 0;
}

